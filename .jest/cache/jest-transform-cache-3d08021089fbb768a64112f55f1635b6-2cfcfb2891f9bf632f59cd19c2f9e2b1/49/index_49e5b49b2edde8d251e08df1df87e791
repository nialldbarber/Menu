6a0bae048d6e4a4dd08aadaa521bd4ce
'use strict';

var _interopRequireDefault2 = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault2(require("@babel/runtime/regenerator"));

var _inherits2 = _interopRequireDefault2(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault2(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault2(require("@babel/runtime/helpers/getPrototypeOf"));

var _wrapNativeSuper2 = _interopRequireDefault2(require("@babel/runtime/helpers/wrapNativeSuper"));

var _slicedToArray2 = _interopRequireDefault2(require("@babel/runtime/helpers/slicedToArray"));

var _defineProperty3 = _interopRequireDefault2(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault2(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault2(require("@babel/runtime/helpers/createClass"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty3.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.default = void 0;

function _chalk() {
  var data = _interopRequireDefault(require('chalk'));

  _chalk = function _chalk() {
    return data;
  };

  return data;
}

function _emittery() {
  var data = _interopRequireDefault(require('emittery'));

  _emittery = function _emittery() {
    return data;
  };

  return data;
}

function _exit() {
  var data = _interopRequireDefault(require('exit'));

  _exit = function _exit() {
    return data;
  };

  return data;
}

function _throat() {
  var data = _interopRequireDefault(require('throat'));

  _throat = function _throat() {
    return data;
  };

  return data;
}

function _jestUtil() {
  var data = require('jest-util');

  _jestUtil = function _jestUtil() {
    return data;
  };

  return data;
}

function _jestWorker() {
  var data = require('jest-worker');

  _jestWorker = function _jestWorker() {
    return data;
  };

  return data;
}

var _runTest = _interopRequireDefault(require("./runTest"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var TEST_WORKER_PATH = require.resolve("./testWorker");

var TestRunner = function () {
  function TestRunner(globalConfig, context) {
    (0, _classCallCheck2.default)(this, TestRunner);

    _defineProperty(this, '_globalConfig', void 0);

    _defineProperty(this, '_context', void 0);

    _defineProperty(this, 'eventEmitter', new (_emittery().default)());

    _defineProperty(this, '__PRIVATE_UNSTABLE_API_supportsEventEmitters__', true);

    _defineProperty(this, 'isSerial', void 0);

    this._globalConfig = globalConfig;
    this._context = context || {};
  }

  (0, _createClass2.default)(TestRunner, [{
    key: "runTests",
    value: function runTests(tests, watcher, onStart, onResult, onFailure, options) {
      return _regenerator.default.async(function runTests$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return _regenerator.default.awrap(options.serial ? this._createInBandTestRun(tests, watcher, onStart, onResult, onFailure) : this._createParallelTestRun(tests, watcher, onStart, onResult, onFailure));

            case 2:
              return _context.abrupt("return", _context.sent);

            case 3:
            case "end":
              return _context.stop();
          }
        }
      }, null, this, null, Promise);
    }
  }, {
    key: "_createInBandTestRun",
    value: function _createInBandTestRun(tests, watcher, onStart, onResult, onFailure) {
      var _this = this;

      var mutex;
      return _regenerator.default.async(function _createInBandTestRun$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              process.env.JEST_WORKER_ID = '1';
              mutex = (0, _throat().default)(1);
              return _context3.abrupt("return", tests.reduce(function (promise, test) {
                return mutex(function () {
                  return promise.then(function _callee() {
                    var sendMessageToJest;
                    return _regenerator.default.async(function _callee$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            if (!watcher.isInterrupted()) {
                              _context2.next = 2;
                              break;
                            }

                            throw new CancelRun();

                          case 2:
                            if (!onStart) {
                              _context2.next = 8;
                              break;
                            }

                            _context2.next = 5;
                            return _regenerator.default.awrap(onStart(test));

                          case 5:
                            return _context2.abrupt("return", (0, _runTest.default)(test.path, _this._globalConfig, test.context.config, test.context.resolver, _this._context, undefined));

                          case 8:
                            sendMessageToJest = function sendMessageToJest(eventName, args) {
                              return _this.eventEmitter.emit(eventName, (0, _jestUtil().deepCyclicCopy)(args, {
                                keepPrototype: false
                              }));
                            };

                            _context2.next = 11;
                            return _regenerator.default.awrap(_this.eventEmitter.emit('test-file-start', [test]));

                          case 11:
                            return _context2.abrupt("return", (0, _runTest.default)(test.path, _this._globalConfig, test.context.config, test.context.resolver, _this._context, sendMessageToJest));

                          case 12:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, null, null, null, Promise);
                  }).then(function (result) {
                    if (onResult) {
                      return onResult(test, result);
                    } else {
                      return _this.eventEmitter.emit('test-file-success', [test, result]);
                    }
                  }).catch(function (err) {
                    if (onFailure) {
                      return onFailure(test, err);
                    } else {
                      return _this.eventEmitter.emit('test-file-failure', [test, err]);
                    }
                  });
                });
              }, Promise.resolve()));

            case 3:
            case "end":
              return _context3.stop();
          }
        }
      }, null, null, null, Promise);
    }
  }, {
    key: "_createParallelTestRun",
    value: function _createParallelTestRun(tests, watcher, onStart, onResult, onFailure) {
      var _this2 = this;

      var resolvers, _iterator, _step, test, worker, mutex, runTestInWorker, onError, onInterrupt, runAllTests, cleanup;

      return _regenerator.default.async(function _createParallelTestRun$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              resolvers = new Map();

              for (_iterator = _createForOfIteratorHelperLoose(tests); !(_step = _iterator()).done;) {
                test = _step.value;

                if (!resolvers.has(test.context.config.name)) {
                  resolvers.set(test.context.config.name, {
                    config: test.context.config,
                    serializableModuleMap: test.context.moduleMap.toJSON()
                  });
                }
              }

              worker = new (_jestWorker().Worker)(TEST_WORKER_PATH, {
                exposedMethods: ['worker'],
                forkOptions: {
                  stdio: 'pipe'
                },
                maxRetries: 3,
                numWorkers: this._globalConfig.maxWorkers,
                setupArgs: [{
                  serializableResolvers: Array.from(resolvers.values())
                }]
              });
              if (worker.getStdout()) worker.getStdout().pipe(process.stdout);
              if (worker.getStderr()) worker.getStderr().pipe(process.stderr);
              mutex = (0, _throat().default)(this._globalConfig.maxWorkers);

              runTestInWorker = function runTestInWorker(test) {
                return mutex(function _callee2() {
                  var promise;
                  return _regenerator.default.async(function _callee2$(_context4) {
                    while (1) {
                      switch (_context4.prev = _context4.next) {
                        case 0:
                          if (!watcher.isInterrupted()) {
                            _context4.next = 2;
                            break;
                          }

                          return _context4.abrupt("return", Promise.reject());

                        case 2:
                          if (!onStart) {
                            _context4.next = 7;
                            break;
                          }

                          _context4.next = 5;
                          return _regenerator.default.awrap(onStart(test));

                        case 5:
                          _context4.next = 9;
                          break;

                        case 7:
                          _context4.next = 9;
                          return _regenerator.default.awrap(_this2.eventEmitter.emit('test-file-start', [test]));

                        case 9:
                          promise = worker.worker({
                            config: test.context.config,
                            context: _objectSpread(_objectSpread({}, _this2._context), {}, {
                              changedFiles: _this2._context.changedFiles && Array.from(_this2._context.changedFiles),
                              sourcesRelatedToTestsInChangedFiles: _this2._context.sourcesRelatedToTestsInChangedFiles && Array.from(_this2._context.sourcesRelatedToTestsInChangedFiles)
                            }),
                            globalConfig: _this2._globalConfig,
                            path: test.path
                          });

                          if (promise.UNSTABLE_onCustomMessage) {
                            promise.UNSTABLE_onCustomMessage(function (_ref) {
                              var _ref2 = (0, _slicedToArray2.default)(_ref, 2),
                                  event = _ref2[0],
                                  payload = _ref2[1];

                              _this2.eventEmitter.emit(event, payload);
                            });
                          }

                          return _context4.abrupt("return", promise);

                        case 12:
                        case "end":
                          return _context4.stop();
                      }
                    }
                  }, null, null, null, Promise);
                });
              };

              onError = function onError(err, test) {
                return _regenerator.default.async(function onError$(_context5) {
                  while (1) {
                    switch (_context5.prev = _context5.next) {
                      case 0:
                        if (!onFailure) {
                          _context5.next = 5;
                          break;
                        }

                        _context5.next = 3;
                        return _regenerator.default.awrap(onFailure(test, err));

                      case 3:
                        _context5.next = 7;
                        break;

                      case 5:
                        _context5.next = 7;
                        return _regenerator.default.awrap(_this2.eventEmitter.emit('test-file-failure', [test, err]));

                      case 7:
                        if (err.type === 'ProcessTerminatedError') {
                          console.error('A worker process has quit unexpectedly! ' + 'Most likely this is an initialization error.');
                          (0, _exit().default)(1);
                        }

                      case 8:
                      case "end":
                        return _context5.stop();
                    }
                  }
                }, null, null, null, Promise);
              };

              onInterrupt = new Promise(function (_, reject) {
                watcher.on('change', function (state) {
                  if (state.interrupted) {
                    reject(new CancelRun());
                  }
                });
              });
              runAllTests = Promise.all(tests.map(function (test) {
                return runTestInWorker(test).then(function (result) {
                  if (onResult) {
                    return onResult(test, result);
                  } else {
                    return _this2.eventEmitter.emit('test-file-success', [test, result]);
                  }
                }).catch(function (error) {
                  return onError(error, test);
                });
              }));

              cleanup = function cleanup() {
                var _await$worker$end, forceExited;

                return _regenerator.default.async(function cleanup$(_context6) {
                  while (1) {
                    switch (_context6.prev = _context6.next) {
                      case 0:
                        _context6.next = 2;
                        return _regenerator.default.awrap(worker.end());

                      case 2:
                        _await$worker$end = _context6.sent;
                        forceExited = _await$worker$end.forceExited;

                        if (forceExited) {
                          console.error(_chalk().default.yellow('A worker process has failed to exit gracefully and has been force exited. ' + 'This is likely caused by tests leaking due to improper teardown. ' + 'Try running with --detectOpenHandles to find leaks. ' + 'Active timers can also cause this, ensure that .unref() was called on them.'));
                        }

                      case 5:
                      case "end":
                        return _context6.stop();
                    }
                  }
                }, null, null, null, Promise);
              };

              return _context7.abrupt("return", Promise.race([runAllTests, onInterrupt]).then(cleanup, cleanup));

            case 12:
            case "end":
              return _context7.stop();
          }
        }
      }, null, this, null, Promise);
    }
  }, {
    key: "on",
    value: function on(eventName, listener) {
      return this.eventEmitter.on(eventName, listener);
    }
  }]);
  return TestRunner;
}();

exports.default = TestRunner;

var CancelRun = function (_Error) {
  (0, _inherits2.default)(CancelRun, _Error);

  var _super = _createSuper(CancelRun);

  function CancelRun(message) {
    var _this3;

    (0, _classCallCheck2.default)(this, CancelRun);
    _this3 = _super.call(this, message);
    _this3.name = 'CancelRun';
    return _this3;
  }

  return (0, _createClass2.default)(CancelRun);
}((0, _wrapNativeSuper2.default)(Error));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZGVmYXVsdCIsIl9jaGFsayIsImRhdGEiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIl9lbWl0dGVyeSIsIl9leGl0IiwiX3Rocm9hdCIsIl9qZXN0VXRpbCIsIl9qZXN0V29ya2VyIiwiX3J1blRlc3QiLCJvYmoiLCJfX2VzTW9kdWxlIiwiX2RlZmluZVByb3BlcnR5Iiwia2V5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiVEVTVF9XT1JLRVJfUEFUSCIsInJlc29sdmUiLCJUZXN0UnVubmVyIiwiZ2xvYmFsQ29uZmlnIiwiY29udGV4dCIsIl9nbG9iYWxDb25maWciLCJfY29udGV4dCIsInRlc3RzIiwid2F0Y2hlciIsIm9uU3RhcnQiLCJvblJlc3VsdCIsIm9uRmFpbHVyZSIsIm9wdGlvbnMiLCJzZXJpYWwiLCJfY3JlYXRlSW5CYW5kVGVzdFJ1biIsIl9jcmVhdGVQYXJhbGxlbFRlc3RSdW4iLCJwcm9jZXNzIiwiZW52IiwiSkVTVF9XT1JLRVJfSUQiLCJtdXRleCIsInJlZHVjZSIsInByb21pc2UiLCJ0ZXN0IiwidGhlbiIsImlzSW50ZXJydXB0ZWQiLCJDYW5jZWxSdW4iLCJwYXRoIiwiY29uZmlnIiwicmVzb2x2ZXIiLCJ1bmRlZmluZWQiLCJzZW5kTWVzc2FnZVRvSmVzdCIsImV2ZW50TmFtZSIsImFyZ3MiLCJldmVudEVtaXR0ZXIiLCJlbWl0IiwiZGVlcEN5Y2xpY0NvcHkiLCJrZWVwUHJvdG90eXBlIiwicmVzdWx0IiwiY2F0Y2giLCJlcnIiLCJQcm9taXNlIiwicmVzb2x2ZXJzIiwiTWFwIiwiaGFzIiwibmFtZSIsInNldCIsInNlcmlhbGl6YWJsZU1vZHVsZU1hcCIsIm1vZHVsZU1hcCIsInRvSlNPTiIsIndvcmtlciIsIldvcmtlciIsImV4cG9zZWRNZXRob2RzIiwiZm9ya09wdGlvbnMiLCJzdGRpbyIsIm1heFJldHJpZXMiLCJudW1Xb3JrZXJzIiwibWF4V29ya2VycyIsInNldHVwQXJncyIsInNlcmlhbGl6YWJsZVJlc29sdmVycyIsIkFycmF5IiwiZnJvbSIsInZhbHVlcyIsImdldFN0ZG91dCIsInBpcGUiLCJzdGRvdXQiLCJnZXRTdGRlcnIiLCJzdGRlcnIiLCJydW5UZXN0SW5Xb3JrZXIiLCJyZWplY3QiLCJjaGFuZ2VkRmlsZXMiLCJzb3VyY2VzUmVsYXRlZFRvVGVzdHNJbkNoYW5nZWRGaWxlcyIsIlVOU1RBQkxFX29uQ3VzdG9tTWVzc2FnZSIsImV2ZW50IiwicGF5bG9hZCIsIm9uRXJyb3IiLCJ0eXBlIiwiY29uc29sZSIsImVycm9yIiwib25JbnRlcnJ1cHQiLCJfIiwib24iLCJzdGF0ZSIsImludGVycnVwdGVkIiwicnVuQWxsVGVzdHMiLCJhbGwiLCJtYXAiLCJjbGVhbnVwIiwiZW5kIiwiZm9yY2VFeGl0ZWQiLCJ5ZWxsb3ciLCJyYWNlIiwibGlzdGVuZXIiLCJtZXNzYWdlIiwiRXJyb3IiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQUEsTUFBTSxDQUFDQyxjQUFQLENBQXNCQyxPQUF0QixFQUErQixZQUEvQixFQUE2QztBQUMzQ0MsRUFBQUEsS0FBSyxFQUFFO0FBRG9DLENBQTdDO0FBR0FELE9BQU8sQ0FBQ0UsT0FBUixHQUFrQixLQUFLLENBQXZCOztBQUVBLFNBQVNDLE1BQVQsR0FBa0I7QUFDaEIsTUFBTUMsSUFBSSxHQUFHQyxzQkFBc0IsQ0FBQ0MsT0FBTyxDQUFDLE9BQUQsQ0FBUixDQUFuQzs7QUFFQUgsRUFBQUEsTUFBTSxHQUFHLGtCQUFZO0FBQ25CLFdBQU9DLElBQVA7QUFDRCxHQUZEOztBQUlBLFNBQU9BLElBQVA7QUFDRDs7QUFFRCxTQUFTRyxTQUFULEdBQXFCO0FBQ25CLE1BQU1ILElBQUksR0FBR0Msc0JBQXNCLENBQUNDLE9BQU8sQ0FBQyxVQUFELENBQVIsQ0FBbkM7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QkFBWW1FLE9BQVosRUFBcUI7QUFBQTs7QUFBQTtBQUNuQiwrQkFBTUEsT0FBTjtBQUNBLFdBQUtoRCxJQUFMLEdBQVksV0FBWjtBQUZtQjtBQUdwQjs7O2lDQUpxQmlELEsiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG5mdW5jdGlvbiBfY2hhbGsoKSB7XG4gIGNvbnN0IGRhdGEgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoJ2NoYWxrJykpO1xuXG4gIF9jaGFsayA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gX2VtaXR0ZXJ5KCkge1xuICBjb25zdCBkYXRhID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKCdlbWl0dGVyeScpKTtcblxuICBfZW1pdHRlcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIF9leGl0KCkge1xuICBjb25zdCBkYXRhID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKCdleGl0JykpO1xuXG4gIF9leGl0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkYXRhO1xuICB9O1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBfdGhyb2F0KCkge1xuICBjb25zdCBkYXRhID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKCd0aHJvYXQnKSk7XG5cbiAgX3Rocm9hdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gX2plc3RVdGlsKCkge1xuICBjb25zdCBkYXRhID0gcmVxdWlyZSgnamVzdC11dGlsJyk7XG5cbiAgX2plc3RVdGlsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkYXRhO1xuICB9O1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBfamVzdFdvcmtlcigpIHtcbiAgY29uc3QgZGF0YSA9IHJlcXVpcmUoJ2plc3Qtd29ya2VyJyk7XG5cbiAgX2plc3RXb3JrZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbnZhciBfcnVuVGVzdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZSgnLi9ydW5UZXN0JykpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge2RlZmF1bHQ6IG9ian07XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuY29uc3QgVEVTVF9XT1JLRVJfUEFUSCA9IHJlcXVpcmUucmVzb2x2ZSgnLi90ZXN0V29ya2VyJyk7XG5cbmNsYXNzIFRlc3RSdW5uZXIge1xuICBjb25zdHJ1Y3RvcihnbG9iYWxDb25maWcsIGNvbnRleHQpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgJ19nbG9iYWxDb25maWcnLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsICdfY29udGV4dCcsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgJ2V2ZW50RW1pdHRlcicsIG5ldyAoX2VtaXR0ZXJ5KCkuZGVmYXVsdCkoKSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoXG4gICAgICB0aGlzLFxuICAgICAgJ19fUFJJVkFURV9VTlNUQUJMRV9BUElfc3VwcG9ydHNFdmVudEVtaXR0ZXJzX18nLFxuICAgICAgdHJ1ZVxuICAgICk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgJ2lzU2VyaWFsJywgdm9pZCAwKTtcblxuICAgIHRoaXMuX2dsb2JhbENvbmZpZyA9IGdsb2JhbENvbmZpZztcbiAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dCB8fCB7fTtcbiAgfVxuXG4gIGFzeW5jIHJ1blRlc3RzKHRlc3RzLCB3YXRjaGVyLCBvblN0YXJ0LCBvblJlc3VsdCwgb25GYWlsdXJlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGF3YWl0IChvcHRpb25zLnNlcmlhbFxuICAgICAgPyB0aGlzLl9jcmVhdGVJbkJhbmRUZXN0UnVuKHRlc3RzLCB3YXRjaGVyLCBvblN0YXJ0LCBvblJlc3VsdCwgb25GYWlsdXJlKVxuICAgICAgOiB0aGlzLl9jcmVhdGVQYXJhbGxlbFRlc3RSdW4oXG4gICAgICAgICAgdGVzdHMsXG4gICAgICAgICAgd2F0Y2hlcixcbiAgICAgICAgICBvblN0YXJ0LFxuICAgICAgICAgIG9uUmVzdWx0LFxuICAgICAgICAgIG9uRmFpbHVyZVxuICAgICAgICApKTtcbiAgfVxuXG4gIGFzeW5jIF9jcmVhdGVJbkJhbmRUZXN0UnVuKHRlc3RzLCB3YXRjaGVyLCBvblN0YXJ0LCBvblJlc3VsdCwgb25GYWlsdXJlKSB7XG4gICAgcHJvY2Vzcy5lbnYuSkVTVF9XT1JLRVJfSUQgPSAnMSc7XG4gICAgY29uc3QgbXV0ZXggPSAoMCwgX3Rocm9hdCgpLmRlZmF1bHQpKDEpO1xuICAgIHJldHVybiB0ZXN0cy5yZWR1Y2UoXG4gICAgICAocHJvbWlzZSwgdGVzdCkgPT5cbiAgICAgICAgbXV0ZXgoKCkgPT5cbiAgICAgICAgICBwcm9taXNlXG4gICAgICAgICAgICAudGhlbihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgIGlmICh3YXRjaGVyLmlzSW50ZXJydXB0ZWQoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBDYW5jZWxSdW4oKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGxldCBzZW5kTWVzc2FnZVRvSmVzdDsgLy8gUmVtb3ZlIGBpZihvblN0YXJ0KWAgaW4gSmVzdCAyN1xuXG4gICAgICAgICAgICAgIGlmIChvblN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgb25TdGFydCh0ZXN0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9ydW5UZXN0LmRlZmF1bHQpKFxuICAgICAgICAgICAgICAgICAgdGVzdC5wYXRoLFxuICAgICAgICAgICAgICAgICAgdGhpcy5fZ2xvYmFsQ29uZmlnLFxuICAgICAgICAgICAgICAgICAgdGVzdC5jb250ZXh0LmNvbmZpZyxcbiAgICAgICAgICAgICAgICAgIHRlc3QuY29udGV4dC5yZXNvbHZlcixcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQsXG4gICAgICAgICAgICAgICAgICB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGBkZWVwQ3ljbGljQ29weWAgdXNlZCBoZXJlIHRvIGF2b2lkIG1lbS1sZWFrXG4gICAgICAgICAgICAgICAgc2VuZE1lc3NhZ2VUb0plc3QgPSAoZXZlbnROYW1lLCBhcmdzKSA9PlxuICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdChcbiAgICAgICAgICAgICAgICAgICAgZXZlbnROYW1lLFxuICAgICAgICAgICAgICAgICAgICAoMCwgX2plc3RVdGlsKCkuZGVlcEN5Y2xpY0NvcHkpKGFyZ3MsIHtcbiAgICAgICAgICAgICAgICAgICAgICBrZWVwUHJvdG90eXBlOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ3Rlc3QtZmlsZS1zdGFydCcsIFt0ZXN0XSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfcnVuVGVzdC5kZWZhdWx0KShcbiAgICAgICAgICAgICAgICAgIHRlc3QucGF0aCxcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2dsb2JhbENvbmZpZyxcbiAgICAgICAgICAgICAgICAgIHRlc3QuY29udGV4dC5jb25maWcsXG4gICAgICAgICAgICAgICAgICB0ZXN0LmNvbnRleHQucmVzb2x2ZXIsXG4gICAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LFxuICAgICAgICAgICAgICAgICAgc2VuZE1lc3NhZ2VUb0plc3RcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgaWYgKG9uUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9uUmVzdWx0KHRlc3QsIHJlc3VsdCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ3Rlc3QtZmlsZS1zdWNjZXNzJywgW1xuICAgICAgICAgICAgICAgICAgdGVzdCxcbiAgICAgICAgICAgICAgICAgIHJlc3VsdFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgIGlmIChvbkZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb25GYWlsdXJlKHRlc3QsIGVycik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ3Rlc3QtZmlsZS1mYWlsdXJlJywgW3Rlc3QsIGVycl0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICApLFxuICAgICAgUHJvbWlzZS5yZXNvbHZlKClcbiAgICApO1xuICB9XG5cbiAgYXN5bmMgX2NyZWF0ZVBhcmFsbGVsVGVzdFJ1bih0ZXN0cywgd2F0Y2hlciwgb25TdGFydCwgb25SZXN1bHQsIG9uRmFpbHVyZSkge1xuICAgIGNvbnN0IHJlc29sdmVycyA9IG5ldyBNYXAoKTtcblxuICAgIGZvciAoY29uc3QgdGVzdCBvZiB0ZXN0cykge1xuICAgICAgaWYgKCFyZXNvbHZlcnMuaGFzKHRlc3QuY29udGV4dC5jb25maWcubmFtZSkpIHtcbiAgICAgICAgcmVzb2x2ZXJzLnNldCh0ZXN0LmNvbnRleHQuY29uZmlnLm5hbWUsIHtcbiAgICAgICAgICBjb25maWc6IHRlc3QuY29udGV4dC5jb25maWcsXG4gICAgICAgICAgc2VyaWFsaXphYmxlTW9kdWxlTWFwOiB0ZXN0LmNvbnRleHQubW9kdWxlTWFwLnRvSlNPTigpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHdvcmtlciA9IG5ldyAoX2plc3RXb3JrZXIoKS5Xb3JrZXIpKFRFU1RfV09SS0VSX1BBVEgsIHtcbiAgICAgIGV4cG9zZWRNZXRob2RzOiBbJ3dvcmtlciddLFxuICAgICAgZm9ya09wdGlvbnM6IHtcbiAgICAgICAgc3RkaW86ICdwaXBlJ1xuICAgICAgfSxcbiAgICAgIG1heFJldHJpZXM6IDMsXG4gICAgICBudW1Xb3JrZXJzOiB0aGlzLl9nbG9iYWxDb25maWcubWF4V29ya2VycyxcbiAgICAgIHNldHVwQXJnczogW1xuICAgICAgICB7XG4gICAgICAgICAgc2VyaWFsaXphYmxlUmVzb2x2ZXJzOiBBcnJheS5mcm9tKHJlc29sdmVycy52YWx1ZXMoKSlcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0pO1xuICAgIGlmICh3b3JrZXIuZ2V0U3Rkb3V0KCkpIHdvcmtlci5nZXRTdGRvdXQoKS5waXBlKHByb2Nlc3Muc3Rkb3V0KTtcbiAgICBpZiAod29ya2VyLmdldFN0ZGVycigpKSB3b3JrZXIuZ2V0U3RkZXJyKCkucGlwZShwcm9jZXNzLnN0ZGVycik7XG4gICAgY29uc3QgbXV0ZXggPSAoMCwgX3Rocm9hdCgpLmRlZmF1bHQpKHRoaXMuX2dsb2JhbENvbmZpZy5tYXhXb3JrZXJzKTsgLy8gU2VuZCB0ZXN0IHN1aXRlcyB0byB3b3JrZXJzIGNvbnRpbnVvdXNseSBpbnN0ZWFkIG9mIGFsbCBhdCBvbmNlIHRvIHRyYWNrXG4gICAgLy8gdGhlIHN0YXJ0IHRpbWUgb2YgaW5kaXZpZHVhbCB0ZXN0cy5cblxuICAgIGNvbnN0IHJ1blRlc3RJbldvcmtlciA9IHRlc3QgPT5cbiAgICAgIG11dGV4KGFzeW5jICgpID0+IHtcbiAgICAgICAgaWYgKHdhdGNoZXIuaXNJbnRlcnJ1cHRlZCgpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCk7XG4gICAgICAgIH0gLy8gUmVtb3ZlIGBpZihvblN0YXJ0KWAgaW4gSmVzdCAyN1xuXG4gICAgICAgIGlmIChvblN0YXJ0KSB7XG4gICAgICAgICAgYXdhaXQgb25TdGFydCh0ZXN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KCd0ZXN0LWZpbGUtc3RhcnQnLCBbdGVzdF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IHdvcmtlci53b3JrZXIoe1xuICAgICAgICAgIGNvbmZpZzogdGVzdC5jb250ZXh0LmNvbmZpZyxcbiAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAuLi50aGlzLl9jb250ZXh0LFxuICAgICAgICAgICAgY2hhbmdlZEZpbGVzOlxuICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmNoYW5nZWRGaWxlcyAmJlxuICAgICAgICAgICAgICBBcnJheS5mcm9tKHRoaXMuX2NvbnRleHQuY2hhbmdlZEZpbGVzKSxcbiAgICAgICAgICAgIHNvdXJjZXNSZWxhdGVkVG9UZXN0c0luQ2hhbmdlZEZpbGVzOlxuICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LnNvdXJjZXNSZWxhdGVkVG9UZXN0c0luQ2hhbmdlZEZpbGVzICYmXG4gICAgICAgICAgICAgIEFycmF5LmZyb20odGhpcy5fY29udGV4dC5zb3VyY2VzUmVsYXRlZFRvVGVzdHNJbkNoYW5nZWRGaWxlcylcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdsb2JhbENvbmZpZzogdGhpcy5fZ2xvYmFsQ29uZmlnLFxuICAgICAgICAgIHBhdGg6IHRlc3QucGF0aFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAocHJvbWlzZS5VTlNUQUJMRV9vbkN1c3RvbU1lc3NhZ2UpIHtcbiAgICAgICAgICAvLyBUT0RPOiBHZXQgYXBwcm9wcmlhdGUgdHlwZSBmb3IgYG9uQ3VzdG9tTWVzc2FnZWBcbiAgICAgICAgICBwcm9taXNlLlVOU1RBQkxFX29uQ3VzdG9tTWVzc2FnZSgoW2V2ZW50LCBwYXlsb2FkXSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdChldmVudCwgcGF5bG9hZCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgIH0pO1xuXG4gICAgY29uc3Qgb25FcnJvciA9IGFzeW5jIChlcnIsIHRlc3QpID0+IHtcbiAgICAgIC8vIFJlbW92ZSBgaWYob25GYWlsdXJlKWAgaW4gSmVzdCAyN1xuICAgICAgaWYgKG9uRmFpbHVyZSkge1xuICAgICAgICBhd2FpdCBvbkZhaWx1cmUodGVzdCwgZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ3Rlc3QtZmlsZS1mYWlsdXJlJywgW3Rlc3QsIGVycl0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXJyLnR5cGUgPT09ICdQcm9jZXNzVGVybWluYXRlZEVycm9yJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICdBIHdvcmtlciBwcm9jZXNzIGhhcyBxdWl0IHVuZXhwZWN0ZWRseSEgJyArXG4gICAgICAgICAgICAnTW9zdCBsaWtlbHkgdGhpcyBpcyBhbiBpbml0aWFsaXphdGlvbiBlcnJvci4nXG4gICAgICAgICk7XG4gICAgICAgICgwLCBfZXhpdCgpLmRlZmF1bHQpKDEpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBvbkludGVycnVwdCA9IG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgIHdhdGNoZXIub24oJ2NoYW5nZScsIHN0YXRlID0+IHtcbiAgICAgICAgaWYgKHN0YXRlLmludGVycnVwdGVkKSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBDYW5jZWxSdW4oKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGNvbnN0IHJ1bkFsbFRlc3RzID0gUHJvbWlzZS5hbGwoXG4gICAgICB0ZXN0cy5tYXAodGVzdCA9PlxuICAgICAgICBydW5UZXN0SW5Xb3JrZXIodGVzdClcbiAgICAgICAgICAudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgaWYgKG9uUmVzdWx0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBvblJlc3VsdCh0ZXN0LCByZXN1bHQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ3Rlc3QtZmlsZS1zdWNjZXNzJywgW1xuICAgICAgICAgICAgICAgIHRlc3QsXG4gICAgICAgICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmNhdGNoKGVycm9yID0+IG9uRXJyb3IoZXJyb3IsIHRlc3QpKVxuICAgICAgKVxuICAgICk7XG5cbiAgICBjb25zdCBjbGVhbnVwID0gYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qge2ZvcmNlRXhpdGVkfSA9IGF3YWl0IHdvcmtlci5lbmQoKTtcblxuICAgICAgaWYgKGZvcmNlRXhpdGVkKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgX2NoYWxrKCkuZGVmYXVsdC55ZWxsb3coXG4gICAgICAgICAgICAnQSB3b3JrZXIgcHJvY2VzcyBoYXMgZmFpbGVkIHRvIGV4aXQgZ3JhY2VmdWxseSBhbmQgaGFzIGJlZW4gZm9yY2UgZXhpdGVkLiAnICtcbiAgICAgICAgICAgICAgJ1RoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSB0ZXN0cyBsZWFraW5nIGR1ZSB0byBpbXByb3BlciB0ZWFyZG93bi4gJyArXG4gICAgICAgICAgICAgICdUcnkgcnVubmluZyB3aXRoIC0tZGV0ZWN0T3BlbkhhbmRsZXMgdG8gZmluZCBsZWFrcy4gJyArXG4gICAgICAgICAgICAgICdBY3RpdmUgdGltZXJzIGNhbiBhbHNvIGNhdXNlIHRoaXMsIGVuc3VyZSB0aGF0IC51bnJlZigpIHdhcyBjYWxsZWQgb24gdGhlbS4nXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtydW5BbGxUZXN0cywgb25JbnRlcnJ1cHRdKS50aGVuKGNsZWFudXAsIGNsZWFudXApO1xuICB9XG5cbiAgb24oZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgIHJldHVybiB0aGlzLmV2ZW50RW1pdHRlci5vbihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgfVxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBUZXN0UnVubmVyO1xuXG5jbGFzcyBDYW5jZWxSdW4gZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSAnQ2FuY2VsUnVuJztcbiAgfVxufVxuIl19